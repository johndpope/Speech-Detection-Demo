<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SphinxBase: include/hash_table.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/hash_table.h File Reference</h1>Hash table implementation.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;sphinxbase_export.h&gt;</code><br>
<code>#include &lt;<a class="el" href="prim__type_8h-source.html">prim_type.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="glist_8h-source.html">glist.h</a>&gt;</code><br>

<p>
<a href="hash__table_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__entry__s.html">hash_entry_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing.  <a href="structhash__entry__s.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_table_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_iter_s</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c98525ff8ec582358783aecbd388842d"></a><!-- doxytag: member="hash_table.h::hash_entry_val" ref="c98525ff8ec582358783aecbd388842d" args="(e)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#c98525ff8ec582358783aecbd388842d">hash_entry_val</a>(e)&nbsp;&nbsp;&nbsp;((e)-&gt;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access macros. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9ff378b212469b2ec6dde13b6f0934b"></a><!-- doxytag: member="hash_table.h::hash_entry_key" ref="a9ff378b212469b2ec6dde13b6f0934b" args="(e)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_entry_key</b>(e)&nbsp;&nbsp;&nbsp;((e)-&gt;key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c0d92dd662edb83d572dc2fef278816"></a><!-- doxytag: member="hash_table.h::hash_entry_len" ref="4c0d92dd662edb83d572dc2fef278816" args="(e)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_entry_len</b>(e)&nbsp;&nbsp;&nbsp;((e)-&gt;len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47264dff359c0a0d4c144e54d0819ce9"></a><!-- doxytag: member="hash_table.h::hash_table_inuse" ref="47264dff359c0a0d4c144e54d0819ce9" args="(h)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_table_inuse</b>(h)&nbsp;&nbsp;&nbsp;((h)-&gt;inuse)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0d9d0efddc207e3d7be3c417dcd7128"></a><!-- doxytag: member="hash_table.h::hash_table_size" ref="a0d9d0efddc207e3d7be3c417dcd7128" args="(h)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_table_size</b>(h)&nbsp;&nbsp;&nbsp;((h)-&gt;size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30fbbcfa2a2d360c2a8960b960ae34a3"></a><!-- doxytag: member="hash_table.h::HASH_CASE_YES" ref="30fbbcfa2a2d360c2a8960b960ae34a3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_YES</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec1a9795611575f717b08d2bad5d6f83"></a><!-- doxytag: member="hash_table.h::HASH_CASE_NO" ref="ec1a9795611575f717b08d2bad5d6f83" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_NO</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#393c56322e54607a48e6bc61169d92bf">hash_table_enter_int32</a>(h, k, v)&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_enter((h),(k),(void *)(long)(v)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a 32-bit integer value to a hash table.  <a href="#393c56322e54607a48e6bc61169d92bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#4286033aa772a9d1f3aa219469324f5b">hash_table_replace_int32</a>(h, k, v)&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_replace((h),(k),(void *)(long)(v)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a 32-bit integer value in a hash table.  <a href="#4286033aa772a9d1f3aa219469324f5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#da31c1e0bcf359a7ca934748f4680333">hash_table_enter_bkey_int32</a>(h, k, l, v)&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_enter_bkey((h),(k),(l),(void *)(long)(v)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter a 32-bit integer value in a hash table.  <a href="#da31c1e0bcf359a7ca934748f4680333"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ce238b264acacb8e6cb0de14f1035f53">hash_table_replace_bkey_int32</a>(h, k, l, v)&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_replace_bkey((h),(k),(l),(void *)(long)(v)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a 32-bit integer value in a hash table.  <a href="#ce238b264acacb8e6cb0de14f1035f53"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#f70e2b25a853da786ffd99731a5fac5a">hash_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing.  <a href="#f70e2b25a853da786ffd99731a5fac5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8febad57d856465fb33dd11cabc57dcc"></a><!-- doxytag: member="hash_table.h::hash_iter_t" ref="8febad57d856465fb33dd11cabc57dcc" args="" -->
typedef struct hash_iter_s&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_iter_t</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT hash_table_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#56d93e8c03e066b77377ac6eab50cfae">hash_table_new</a> (int32 size, int32 casearg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new hash table for a given expected size.  <a href="#56d93e8c03e066b77377ac6eab50cfae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#0a588c22946f8cc16328973035ed19e3">hash_table_free</a> (hash_table_t *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries.  <a href="#0a588c22946f8cc16328973035ed19e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ebfe63c3869c271b125a8413ee384412">hash_table_enter</a> (hash_table_t *h, const char *key, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to add a new entry with given key and associated value to hash table h.  <a href="#ebfe63c3869c271b125a8413ee384412"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#e61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a> (hash_table_t *h, const char *key, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new entry with given key and value to hash table h.  <a href="#e61b28ea189a98ef8f2a3c5521482968"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#f1d87b1b825c302473f2d7c5a3b88475">hash_table_delete</a> (hash_table_t *h, const char *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an entry with given key and associated value to hash table h.  <a href="#f1d87b1b825c302473f2d7c5a3b88475"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a2ab1f5eb2f1b4689645d1e1c19dc887">hash_table_delete_bkey</a> (hash_table_t *h, const char *key, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like hash_table_delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#a2ab1f5eb2f1b4689645d1e1c19dc887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#cab374d21e25009d397642e3465308c7">hash_table_empty</a> (hash_table_t *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all entries from a hash_table.  <a href="#cab374d21e25009d397642e3465308c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a> (hash_table_t *h, const char *key, size_t len, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like hash_table_enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#6f5752fadefe2662adb2c141f1511062"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a> (hash_table_t *h, const char *key, size_t len, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like hash_table_replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#273237d63833e5625c830f421d9463de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#9a1e5ed410eb96f514b00fdce770fbd7">hash_table_lookup</a> (hash_table_t *h, const char *key, void **val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a key in a hash table and optionally return the associated value.  <a href="#9a1e5ed410eb96f514b00fdce770fbd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#caf27e8e7e336faf6653649937c42ed8">hash_table_lookup_int32</a> (hash_table_t *h, const char *key, int32 *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a 32-bit integer value in a hash table.  <a href="#caf27e8e7e336faf6653649937c42ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#91f5b3924c0e3a50f94c86bb5fd078e8">hash_table_lookup_bkey</a> (hash_table_t *h, const char *key, size_t len, void **val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#91f5b3924c0e3a50f94c86bb5fd078e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#cc530eda0b105745cf3a47cc3c1148e4">hash_table_lookup_bkey_int32</a> (hash_table_t *h, const char *key, size_t len, int32 *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a 32-bit integer value in a hash table.  <a href="#cc530eda0b105745cf3a47cc3c1148e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae6e6373d3c371d57861a9a875edb207"></a><!-- doxytag: member="hash_table.h::hash_table_iter" ref="ae6e6373d3c371d57861a9a875edb207" args="(hash_table_t *h)" -->
SPHINXBASE_EXPORT hash_iter_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ae6e6373d3c371d57861a9a875edb207">hash_table_iter</a> (hash_table_t *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start iterating over key-value pairs in a hash table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT hash_iter_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#d023321efab26a30bd6d855fbdbe08a3">hash_table_iter_next</a> (hash_iter_t *itor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next key-value pair in iteration.  <a href="#d023321efab26a30bd6d855fbdbe08a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7aa43b228d7dc24f5221d281debeb025"></a><!-- doxytag: member="hash_table.h::hash_table_iter_free" ref="7aa43b228d7dc24f5221d281debeb025" args="(hash_iter_t *itor)" -->
SPHINXBASE_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#7aa43b228d7dc24f5221d281debeb025">hash_table_iter_free</a> (hash_iter_t *itor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an unfinished iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#61f59389f05d8871003da4692a9c2acc">hash_table_tolist</a> (hash_table_t *h, int32 *count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a glist of valid hash_entry_t pointers from the given hash table.  <a href="#61f59389f05d8871003da4692a9c2acc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPHINXBASE_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#2721f6b601c80ceeeae570589fd12e38">hash_table_display</a> (hash_table_t *h, int32 showkey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a hash-with-chaining representation on the screen.  <a href="#2721f6b601c80ceeeae570589fd12e38"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Hash table implementation. 
<p>
This hash tables are intended for associating a pointer/integer "value" with a char string "key", (e.g., an ID with a word string). Subsequently, one can retrieve the value by providing the string key. (The reverse functionality--obtaining the string given the value--is not provided with the hash table module.) 
<p>Definition in file <a class="el" href="hash__table_8h-source.html">hash_table.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="da31c1e0bcf359a7ca934748f4680333"></a><!-- doxytag: member="hash_table.h::hash_table_enter_bkey_int32" ref="da31c1e0bcf359a7ca934748f4680333" args="(h, k, l, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_bkey_int32          </td>
          <td>(</td>
          <td class="paramtype">h,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">l,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_enter_bkey((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enter a 32-bit integer value in a hash table. 
<p>
This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 
<p>Definition at line <a class="el" href="hash__table_8h-source.html#l00315">315</a> of file <a class="el" href="hash__table_8h-source.html">hash_table.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="393c56322e54607a48e6bc61169d92bf"></a><!-- doxytag: member="hash_table.h::hash_table_enter_int32" ref="393c56322e54607a48e6bc61169d92bf" args="(h, k, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_int32          </td>
          <td>(</td>
          <td class="paramtype">h,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_enter((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a 32-bit integer value to a hash table. 
<p>
This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 
<p>Definition at line <a class="el" href="hash__table_8h-source.html#l00228">228</a> of file <a class="el" href="hash__table_8h-source.html">hash_table.h</a>.</p>

<p>Referenced by <a class="el" href="ngram__model_8c-source.html#l00296">ngram_model_casefold()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00637">ngram_model_set_map_words()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ce238b264acacb8e6cb0de14f1035f53"></a><!-- doxytag: member="hash_table.h::hash_table_replace_bkey_int32" ref="ce238b264acacb8e6cb0de14f1035f53" args="(h, k, l, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_bkey_int32          </td>
          <td>(</td>
          <td class="paramtype">h,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">l,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_replace_bkey((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a 32-bit integer value in a hash table. 
<p>
This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 
<p>Definition at line <a class="el" href="hash__table_8h-source.html#l00338">338</a> of file <a class="el" href="hash__table_8h-source.html">hash_table.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4286033aa772a9d1f3aa219469324f5b"></a><!-- doxytag: member="hash_table.h::hash_table_replace_int32" ref="4286033aa772a9d1f3aa219469324f5b" args="(h, k, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_int32          </td>
          <td>(</td>
          <td class="paramtype">h,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int32)(long)hash_table_replace((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a 32-bit integer value in a hash table. 
<p>
This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 
<p>Definition at line <a class="el" href="hash__table_8h-source.html#l00257">257</a> of file <a class="el" href="hash__table_8h-source.html">hash_table.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="f70e2b25a853da786ffd99731a5fac5a"></a><!-- doxytag: member="hash_table.h::hash_entry_t" ref="f70e2b25a853da786ffd99731a5fac5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a>  <a class="el" href="structhash__entry__s.html">hash_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing. 
<p>
There are definitely better ways to do internal hashing (i.e. when everything is stored in the memory.) In Sphinx 3, this is a reasonable practice because hash table is only used in lookup in initialization or in lookups which is not critical for speed. Another note by ARCHAN at 20050703: To use this data structure properly, it is very important to realize that the users are required to handle memory allocation of the C-style keys. The hash table will not make a copy of the memory allocated for any of the C-style key. It will not allocate memory for it. It will not delete memory for it. As a result, the following code sniplet will cause memory leak.<p>
while (1){ str=(char*)ckd_calloc(str_length,sizeof(char*)) if(hash_enter(ht,str,id)!=id){ printf("fail to add key str %s with val id %d\n",str,id)} } A note by dhuggins on 20061010: Changed this to use void * instead of int32 as the value type, so that arbitrary objects can be inserted into a hash table (in a way that won't crash on 64-bit machines ;) The hash table structures. Each hash table is identified by a hash_table_t structure. hash_table_t.table is pre-allocated for a user-controlled max size, and is initially empty. As new entries are created (using hash_enter()), the empty entries get filled. If multiple keys hash to the same entry, new entries are allocated and linked together in a linear list. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="f1d87b1b825c302473f2d7c5a3b88475"></a><!-- doxytag: member="hash_table.h::hash_table_delete" ref="f1d87b1b825c302473f2d7c5a3b88475" args="(hash_table_t *h, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete an entry with given key and associated value to hash table h. 
<p>
Return the value associated with the key (NULL if it did not exist) <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which a key will be deleted </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated key string for the new entry </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00530">530</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00530">hash_table_delete()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00530">hash_table_delete()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a2ab1f5eb2f1b4689645d1e1c19dc887"></a><!-- doxytag: member="hash_table.h::hash_table_delete_bkey" ref="a2ab1f5eb2f1b4689645d1e1c19dc887" args="(hash_table_t *h, const char *key, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete_bkey           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like hash_table_delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 
<p>
So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which a key will be deleted </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated key string for the new entry </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00568">568</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00568">hash_table_delete_bkey()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00568">hash_table_delete_bkey()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2721f6b601c80ceeeae570589fd12e38"></a><!-- doxytag: member="hash_table.h::hash_table_display" ref="2721f6b601c80ceeeae570589fd12e38" args="(hash_table_t *h, int32 showkey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_display           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>showkey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a hash-with-chaining representation on the screen. 
<p>
Currently, it will only works for situation where hash_enter was used to enter the keys. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Hash table to display </td></tr>
<tr><td valign="top"><em>showkey</em>&nbsp;</td><td>
In: Show the string or not, Use 0 if hash_enter_bkey was used. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00580">580</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="err_8h-source.html#l00165">E_INFOCONT</a>, <a class="el" href="hash__table_8c-source.html#l00580">hash_table_display()</a>, <a class="el" href="hash__table_8h-source.html#l00150">hash_entry_s::key</a>, <a class="el" href="hash__table_8h-source.html#l00153">hash_entry_s::len</a>, <a class="el" href="hash__table_8h-source.html#l00156">hash_entry_s::next</a>, and <a class="el" href="hash__table_8h-source.html#l00155">hash_entry_s::val</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00580">hash_table_display()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cab374d21e25009d397642e3465308c7"></a><!-- doxytag: member="hash_table.h::hash_table_empty" ref="cab374d21e25009d397642e3465308c7" args="(hash_table_t *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_empty           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete all entries from a hash_table. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00490">490</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c-source.html#l00241">ckd_free()</a>, <a class="el" href="hash__table_8c-source.html#l00490">hash_table_empty()</a>, and <a class="el" href="hash__table_8h-source.html#l00156">hash_entry_s::next</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00490">hash_table_empty()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00637">ngram_model_set_map_words()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ebfe63c3869c271b125a8413ee384412"></a><!-- doxytag: member="hash_table.h::hash_table_enter" ref="ebfe63c3869c271b125a8413ee384412" args="(hash_table_t *h, const char *key, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to add a new entry with given key and associated value to hash table h. 
<p>
If key doesn't already exist in hash table, the addition is successful, and the return value is val. But if key already exists, return its existing associated value. (The hash table is unchanged; it is up to the caller to resolve the conflict.) <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which to create entry </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated key string for the new entry </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
In: Value to be associated with above key </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00508">508</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00508">hash_table_enter()</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00504">cmd_ln_parse_r()</a>, <a class="el" href="hash__table_8c-source.html#l00508">hash_table_enter()</a>, and <a class="el" href="huff__code_8c-source.html#l00309">huff_code_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6f5752fadefe2662adb2c141f1511062"></a><!-- doxytag: member="hash_table.h::hash_table_enter_bkey" ref="6f5752fadefe2662adb2c141f1511062" args="(hash_table_t *h, const char *key, size_t len, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter_bkey           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like hash_table_enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 
<p>
So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which to create entry </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: Key buffer </td></tr>
<tr><td valign="top"><em>len</em>&nbsp;</td><td>
In: Length of above key buffer </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
In: Value to be associated with above key </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00542">542</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c-source.html#l00241">ckd_free()</a>, and <a class="el" href="hash__table_8c-source.html#l00542">hash_table_enter_bkey()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00542">hash_table_enter_bkey()</a>, and <a class="el" href="huff__code_8c-source.html#l00309">huff_code_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a588c22946f8cc16328973035ed19e3"></a><!-- doxytag: member="hash_table.h::hash_table_free" ref="0a588c22946f8cc16328973035ed19e3" args="(hash_table_t *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_free           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table to free </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00692">692</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c-source.html#l00241">ckd_free()</a>, <a class="el" href="hash__table_8c-source.html#l00692">hash_table_free()</a>, and <a class="el" href="hash__table_8h-source.html#l00156">hash_entry_s::next</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00963">cmd_ln_free_r()</a>, <a class="el" href="cmd__ln_8c-source.html#l00504">cmd_ln_parse_r()</a>, <a class="el" href="hash__table_8c-source.html#l00692">hash_table_free()</a>, <a class="el" href="huff__code_8c-source.html#l00450">huff_code_free()</a>, <a class="el" href="jsgf_8c-source.html#l00127">jsgf_grammar_free()</a>, <a class="el" href="ngram__model_8c-source.html#l00296">ngram_model_casefold()</a>, <a class="el" href="ngram__model_8c-source.html#l00251">ngram_model_free()</a>, <a class="el" href="ngram__model_8c-source.html#l01191">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d023321efab26a30bd6d855fbdbe08a3"></a><!-- doxytag: member="hash_table.h::hash_table_iter_next" ref="d023321efab26a30bd6d855fbdbe08a3" args="(hash_iter_t *itor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT hash_iter_t* hash_table_iter_next           </td>
          <td>(</td>
          <td class="paramtype">hash_iter_t *&nbsp;</td>
          <td class="paramname"> <em>itor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the next key-value pair in iteration. 
<p>
This function automatically frees the iterator object upon reaching the final entry.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the next entry in the hash table, or NULL if done. </dd></dl>

<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00660">660</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00686">hash_table_iter_free()</a>, and <a class="el" href="hash__table_8c-source.html#l00660">hash_table_iter_next()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00650">hash_table_iter()</a>, <a class="el" href="hash__table_8c-source.html#l00660">hash_table_iter_next()</a>, and <a class="el" href="jsgf_8c-source.html#l00127">jsgf_grammar_free()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a1e5ed410eb96f514b00fdce770fbd7"></a><!-- doxytag: member="hash_table.h::hash_table_lookup" ref="9a1e5ed410eb96f514b00fdce770fbd7" args="(hash_table_t *h, const char *key, void **val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a key in a hash table and optionally return the associated value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if key found in hash table, else -1. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table being searched </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated string whose value is sought </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00309">309</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00309">hash_table_lookup()</a>, and <a class="el" href="hash__table_8h-source.html#l00155">hash_entry_s::val</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00875">cmd_ln_access_r()</a>, <a class="el" href="cmd__ln_8c-source.html#l00866">cmd_ln_exists_r()</a>, <a class="el" href="cmd__ln_8c-source.html#l00504">cmd_ln_parse_r()</a>, <a class="el" href="hash__table_8c-source.html#l00309">hash_table_lookup()</a>, <a class="el" href="hash__table_8c-source.html#l00329">hash_table_lookup_int32()</a>, <a class="el" href="huff__code_8c-source.html#l00516">huff_code_encode_str()</a>, <a class="el" href="jsgf_8c-source.html#l00423">jsgf_get_rule()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="91f5b3924c0e3a50f94c86bb5fd078e8"></a><!-- doxytag: member="hash_table.h::hash_table_lookup_bkey" ref="91f5b3924c0e3a50f94c86bb5fd078e8" args="(hash_table_t *h, const char *key, size_t len, void **val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 
<p>
So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table being searched </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: Key buffer </td></tr>
<tr><td valign="top"><em>len</em>&nbsp;</td><td>
In: Length of above key buffer </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00344">344</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c-source.html#l00241">ckd_free()</a>, <a class="el" href="hash__table_8c-source.html#l00344">hash_table_lookup_bkey()</a>, and <a class="el" href="hash__table_8h-source.html#l00155">hash_entry_s::val</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00344">hash_table_lookup_bkey()</a>, <a class="el" href="hash__table_8c-source.html#l00365">hash_table_lookup_bkey_int32()</a>, and <a class="el" href="huff__code_8c-source.html#l00500">huff_code_encode_int()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc530eda0b105745cf3a47cc3c1148e4"></a><!-- doxytag: member="hash_table.h::hash_table_lookup_bkey_int32" ref="cc530eda0b105745cf3a47cc3c1148e4" args="(hash_table_t *h, const char *key, size_t len, int32 *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey_int32           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a 32-bit integer value in a hash table. 
<p>
This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table being searched </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: Key buffer </td></tr>
<tr><td valign="top"><em>len</em>&nbsp;</td><td>
In: Length of above key buffer </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00365">365</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00344">hash_table_lookup_bkey()</a>, and <a class="el" href="hash__table_8c-source.html#l00365">hash_table_lookup_bkey_int32()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00365">hash_table_lookup_bkey_int32()</a>.</p>

</div>
</div><p>
<a class="anchor" name="caf27e8e7e336faf6653649937c42ed8"></a><!-- doxytag: member="hash_table.h::hash_table_lookup_int32" ref="caf27e8e7e336faf6653649937c42ed8" args="(hash_table_t *h, const char *key, int32 *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_int32           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a 32-bit integer value in a hash table. 
<p>
This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table being searched </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated string whose value is sought </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00329">329</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00309">hash_table_lookup()</a>, and <a class="el" href="hash__table_8c-source.html#l00329">hash_table_lookup_int32()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00329">hash_table_lookup_int32()</a>, <a class="el" href="ngram__model_8c-source.html#l00641">ngram_unknown_wid()</a>, and <a class="el" href="ngram__model_8c-source.html#l00768">ngram_wid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="56d93e8c03e066b77377ac6eab50cfae"></a><!-- doxytag: member="hash_table.h::hash_table_new" ref="56d93e8c03e066b77377ac6eab50cfae" args="(int32 size, int32 casearg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT hash_table_t* hash_table_new           </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>casearg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new hash table for a given expected size. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Case sensitivity of hash keys applies to 7-bit ASCII characters only, and is not locale-dependent.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>handle to allocated hash table. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
In: Expected number of entries in the table </td></tr>
<tr><td valign="top"><em>casearg</em>&nbsp;</td><td>
In: Whether case insensitive for key comparisons. When 1, case is insentitive, 0, case is sensitive. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00158">158</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8h-source.html#l00230">ckd_calloc</a>, and <a class="el" href="hash__table_8c-source.html#l00158">hash_table_new()</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00504">cmd_ln_parse_r()</a>, <a class="el" href="hash__table_8c-source.html#l00158">hash_table_new()</a>, <a class="el" href="huff__code_8c-source.html#l00309">huff_code_read()</a>, <a class="el" href="jsgf_8c-source.html#l00081">jsgf_grammar_new()</a>, <a class="el" href="ngram__model_8c-source.html#l00296">ngram_model_casefold()</a>, <a class="el" href="ngram__model_8c-source.html#l01191">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e61b28ea189a98ef8f2a3c5521482968"></a><!-- doxytag: member="hash_table.h::hash_table_replace" ref="e61b28ea189a98ef8f2a3c5521482968" args="(hash_table_t *h, const char *key, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new entry with given key and value to hash table h. 
<p>
If the key already exists, its value is replaced with the given value, and the previous value is returned, otherwise val is returned.<p>
A very important but subtle point: The key pointer in the hash table is <b>replaced</b> with the pointer passed to this function. In general you should always pass a pointer to <a class="el" href="hash__table_8h.html#ebfe63c3869c271b125a8413ee384412" title="Try to add a new entry with given key and associated value to hash table h.">hash_table_enter()</a> whose lifetime matches or exceeds that of the hash table. In some rare cases it is convenient to initially enter a value with a short-lived key, then later replace that with a long-lived one. This behaviour allows this to happen. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which to create entry </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: C-style NULL-terminated key string for the new entry </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
In: Value to be associated with above key </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00519">519</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c-source.html#l00519">hash_table_replace()</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00504">cmd_ln_parse_r()</a>, and <a class="el" href="hash__table_8c-source.html#l00519">hash_table_replace()</a>.</p>

</div>
</div><p>
<a class="anchor" name="273237d63833e5625c830f421d9463de"></a><!-- doxytag: member="hash_table.h::hash_table_replace_bkey" ref="273237d63833e5625c830f421d9463de" args="(hash_table_t *h, const char *key, size_t len, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace_bkey           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like hash_table_replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 
<p>
So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Handle of hash table in which to create entry </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
In: Key buffer </td></tr>
<tr><td valign="top"><em>len</em>&nbsp;</td><td>
In: Length of above key buffer </td></tr>
<tr><td valign="top"><em>val</em>&nbsp;</td><td>
In: Value to be associated with above key </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00555">555</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c-source.html#l00241">ckd_free()</a>, and <a class="el" href="hash__table_8c-source.html#l00555">hash_table_replace_bkey()</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c-source.html#l00555">hash_table_replace_bkey()</a>.</p>

</div>
</div><p>
<a class="anchor" name="61f59389f05d8871003da4692a9c2acc"></a><!-- doxytag: member="hash_table.h::hash_table_tolist" ref="61f59389f05d8871003da4692a9c2acc" args="(hash_table_t *h, int32 *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a> hash_table_tolist           </td>
          <td>(</td>
          <td class="paramtype">hash_table_t *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a glist of valid hash_entry_t pointers from the given hash table. 
<p>
Return the list. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>h</em>&nbsp;</td><td>
In: Hash table from which list is to be generated </td></tr>
<tr><td valign="top"><em>count</em>&nbsp;</td><td>
Out: Number of entries in the list. If this is NULL, no count will be returned. </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="hash__table_8c-source.html#l00620">620</a> of file <a class="el" href="hash__table_8c-source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="glist_8c-source.html#l00074">glist_add_ptr()</a>, <a class="el" href="hash__table_8c-source.html#l00620">hash_table_tolist()</a>, and <a class="el" href="hash__table_8h-source.html#l00150">hash_entry_s::key</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c-source.html#l00963">cmd_ln_free_r()</a>, <a class="el" href="hash__table_8c-source.html#l00620">hash_table_tolist()</a>, <a class="el" href="ngram__model_8c-source.html#l01191">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c-source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Dec 3 20:28:38 2011 for SphinxBase by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
