\section{include/hash\_\-table.h File Reference}
\label{hash__table_8h}\index{include/hash\_\-table.h@{include/hash\_\-table.h}}
Hash table implementation.  


{\tt \#include $<$sphinxbase\_\-export.h$>$}\par
{\tt \#include $<$prim\_\-type.h$>$}\par
{\tt \#include $<$glist.h$>$}\par
\subsection*{Data Structures}
\begin{CompactItemize}
\item 
struct {\bf hash\_\-entry\_\-s}
\begin{CompactList}\small\item\em A note by ARCHAN at 20050510: Technically what we use is so-called \char`\"{}hash table with buckets\char`\"{} which is very nice way to deal with external hashing. \item\end{CompactList}\item 
struct \textbf{hash\_\-table\_\-t}
\item 
struct \textbf{hash\_\-iter\_\-s}
\end{CompactItemize}
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define {\bf hash\_\-entry\_\-val}(e)~((e) $\rightarrow$ val)\label{hash__table_8h_c98525ff8ec582358783aecbd388842d}

\begin{CompactList}\small\item\em Access macros. \item\end{CompactList}\item 
\#define \textbf{hash\_\-entry\_\-key}(e)~((e) $\rightarrow$ key)\label{hash__table_8h_a9ff378b212469b2ec6dde13b6f0934b}

\item 
\#define \textbf{hash\_\-entry\_\-len}(e)~((e) $\rightarrow$ len)\label{hash__table_8h_4c0d92dd662edb83d572dc2fef278816}

\item 
\#define \textbf{hash\_\-table\_\-inuse}(h)~((h) $\rightarrow$ inuse)\label{hash__table_8h_47264dff359c0a0d4c144e54d0819ce9}

\item 
\#define \textbf{hash\_\-table\_\-size}(h)~((h) $\rightarrow$ size)\label{hash__table_8h_a0d9d0efddc207e3d7be3c417dcd7128}

\item 
\#define \textbf{HASH\_\-CASE\_\-YES}~0\label{hash__table_8h_30fbbcfa2a2d360c2a8960b960ae34a3}

\item 
\#define \textbf{HASH\_\-CASE\_\-NO}~1\label{hash__table_8h_ec1a9795611575f717b08d2bad5d6f83}

\item 
\#define {\bf hash\_\-table\_\-enter\_\-int32}(h, k, v)~((int32)(long)hash\_\-table\_\-enter((h),(k),(void $\ast$)(long)(v)))
\begin{CompactList}\small\item\em Add a 32-bit integer value to a hash table. \item\end{CompactList}\item 
\#define {\bf hash\_\-table\_\-replace\_\-int32}(h, k, v)~((int32)(long)hash\_\-table\_\-replace((h),(k),(void $\ast$)(long)(v)))
\begin{CompactList}\small\item\em Replace a 32-bit integer value in a hash table. \item\end{CompactList}\item 
\#define {\bf hash\_\-table\_\-enter\_\-bkey\_\-int32}(h, k, l, v)~((int32)(long)hash\_\-table\_\-enter\_\-bkey((h),(k),(l),(void $\ast$)(long)(v)))
\begin{CompactList}\small\item\em Enter a 32-bit integer value in a hash table. \item\end{CompactList}\item 
\#define {\bf hash\_\-table\_\-replace\_\-bkey\_\-int32}(h, k, l, v)~((int32)(long)hash\_\-table\_\-replace\_\-bkey((h),(k),(l),(void $\ast$)(long)(v)))
\begin{CompactList}\small\item\em Replace a 32-bit integer value in a hash table. \item\end{CompactList}\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef struct {\bf hash\_\-entry\_\-s} {\bf hash\_\-entry\_\-t}
\begin{CompactList}\small\item\em A note by ARCHAN at 20050510: Technically what we use is so-called \char`\"{}hash table with buckets\char`\"{} which is very nice way to deal with external hashing. \item\end{CompactList}\item 
typedef struct hash\_\-iter\_\-s \textbf{hash\_\-iter\_\-t}\label{hash__table_8h_8febad57d856465fb33dd11cabc57dcc}

\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
SPHINXBASE\_\-EXPORT hash\_\-table\_\-t $\ast$ {\bf hash\_\-table\_\-new} (int32 size, int32 casearg)
\begin{CompactList}\small\item\em Allocate a new hash table for a given expected size. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf hash\_\-table\_\-free} (hash\_\-table\_\-t $\ast$h)
\begin{CompactList}\small\item\em Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-enter} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, void $\ast$val)
\begin{CompactList}\small\item\em Try to add a new entry with given key and associated value to hash table h. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-replace} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, void $\ast$val)
\begin{CompactList}\small\item\em Add a new entry with given key and value to hash table h. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-delete} (hash\_\-table\_\-t $\ast$h, const char $\ast$key)
\begin{CompactList}\small\item\em Delete an entry with given key and associated value to hash table h. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-delete\_\-bkey} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, size\_\-t len)
\begin{CompactList}\small\item\em Like hash\_\-table\_\-delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf hash\_\-table\_\-empty} (hash\_\-table\_\-t $\ast$h)
\begin{CompactList}\small\item\em Delete all entries from a hash\_\-table. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-enter\_\-bkey} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, size\_\-t len, void $\ast$val)
\begin{CompactList}\small\item\em Like hash\_\-table\_\-enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void $\ast$ {\bf hash\_\-table\_\-replace\_\-bkey} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, size\_\-t len, void $\ast$val)
\begin{CompactList}\small\item\em Like hash\_\-table\_\-replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf hash\_\-table\_\-lookup} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, void $\ast$$\ast$val)
\begin{CompactList}\small\item\em Look up a key in a hash table and optionally return the associated value. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf hash\_\-table\_\-lookup\_\-int32} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, int32 $\ast$val)
\begin{CompactList}\small\item\em Look up a 32-bit integer value in a hash table. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf hash\_\-table\_\-lookup\_\-bkey} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, size\_\-t len, void $\ast$$\ast$val)
\begin{CompactList}\small\item\em Like hash\_\-lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf hash\_\-table\_\-lookup\_\-bkey\_\-int32} (hash\_\-table\_\-t $\ast$h, const char $\ast$key, size\_\-t len, int32 $\ast$val)
\begin{CompactList}\small\item\em Look up a 32-bit integer value in a hash table. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT hash\_\-iter\_\-t $\ast$ {\bf hash\_\-table\_\-iter} (hash\_\-table\_\-t $\ast$h)\label{hash__table_8h_ae6e6373d3c371d57861a9a875edb207}

\begin{CompactList}\small\item\em Start iterating over key-value pairs in a hash table. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT hash\_\-iter\_\-t $\ast$ {\bf hash\_\-table\_\-iter\_\-next} (hash\_\-iter\_\-t $\ast$itor)
\begin{CompactList}\small\item\em Get the next key-value pair in iteration. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf hash\_\-table\_\-iter\_\-free} (hash\_\-iter\_\-t $\ast$itor)\label{hash__table_8h_7aa43b228d7dc24f5221d281debeb025}

\begin{CompactList}\small\item\em Delete an unfinished iterator. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT {\bf glist\_\-t} {\bf hash\_\-table\_\-tolist} (hash\_\-table\_\-t $\ast$h, int32 $\ast$count)
\begin{CompactList}\small\item\em Build a glist of valid hash\_\-entry\_\-t pointers from the given hash table. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf hash\_\-table\_\-display} (hash\_\-table\_\-t $\ast$h, int32 showkey)
\begin{CompactList}\small\item\em Display a hash-with-chaining representation on the screen. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Hash table implementation. 

This hash tables are intended for associating a pointer/integer \char`\"{}value\char`\"{} with a char string \char`\"{}key\char`\"{}, (e.g., an ID with a word string). Subsequently, one can retrieve the value by providing the string key. (The reverse functionality--obtaining the string given the value--is not provided with the hash table module.) 

Definition in file {\bf hash\_\-table.h}.

\subsection{Define Documentation}
\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-enter\_\-bkey\_\-int32@{hash\_\-table\_\-enter\_\-bkey\_\-int32}}
\index{hash\_\-table\_\-enter\_\-bkey\_\-int32@{hash\_\-table\_\-enter\_\-bkey\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-enter\_\-bkey\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}\#define hash\_\-table\_\-enter\_\-bkey\_\-int32(h, \/  k, \/  l, \/  v)~((int32)(long)hash\_\-table\_\-enter\_\-bkey((h),(k),(l),(void $\ast$)(long)(v)))}\label{hash__table_8h_da31c1e0bcf359a7ca934748f4680333}


Enter a 32-bit integer value in a hash table. 

This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 

Definition at line 315 of file hash\_\-table.h.\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-enter\_\-int32@{hash\_\-table\_\-enter\_\-int32}}
\index{hash\_\-table\_\-enter\_\-int32@{hash\_\-table\_\-enter\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-enter\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}\#define hash\_\-table\_\-enter\_\-int32(h, \/  k, \/  v)~((int32)(long)hash\_\-table\_\-enter((h),(k),(void $\ast$)(long)(v)))}\label{hash__table_8h_393c56322e54607a48e6bc61169d92bf}


Add a 32-bit integer value to a hash table. 

This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 

Definition at line 228 of file hash\_\-table.h.

Referenced by ngram\_\-model\_\-casefold(), and ngram\_\-model\_\-set\_\-map\_\-words().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-replace\_\-bkey\_\-int32@{hash\_\-table\_\-replace\_\-bkey\_\-int32}}
\index{hash\_\-table\_\-replace\_\-bkey\_\-int32@{hash\_\-table\_\-replace\_\-bkey\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-replace\_\-bkey\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}\#define hash\_\-table\_\-replace\_\-bkey\_\-int32(h, \/  k, \/  l, \/  v)~((int32)(long)hash\_\-table\_\-replace\_\-bkey((h),(k),(l),(void $\ast$)(long)(v)))}\label{hash__table_8h_ce238b264acacb8e6cb0de14f1035f53}


Replace a 32-bit integer value in a hash table. 

This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 

Definition at line 338 of file hash\_\-table.h.\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-replace\_\-int32@{hash\_\-table\_\-replace\_\-int32}}
\index{hash\_\-table\_\-replace\_\-int32@{hash\_\-table\_\-replace\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-replace\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}\#define hash\_\-table\_\-replace\_\-int32(h, \/  k, \/  v)~((int32)(long)hash\_\-table\_\-replace((h),(k),(void $\ast$)(long)(v)))}\label{hash__table_8h_4286033aa772a9d1f3aa219469324f5b}


Replace a 32-bit integer value in a hash table. 

This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. 

Definition at line 257 of file hash\_\-table.h.

\subsection{Typedef Documentation}
\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-entry\_\-t@{hash\_\-entry\_\-t}}
\index{hash\_\-entry\_\-t@{hash\_\-entry\_\-t}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-entry\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf hash\_\-entry\_\-s}  {\bf hash\_\-entry\_\-t}}\label{hash__table_8h_f70e2b25a853da786ffd99731a5fac5a}


A note by ARCHAN at 20050510: Technically what we use is so-called \char`\"{}hash table with buckets\char`\"{} which is very nice way to deal with external hashing. 

There are definitely better ways to do internal hashing (i.e. when everything is stored in the memory.) In Sphinx 3, this is a reasonable practice because hash table is only used in lookup in initialization or in lookups which is not critical for speed. Another note by ARCHAN at 20050703: To use this data structure properly, it is very important to realize that the users are required to handle memory allocation of the C-style keys. The hash table will not make a copy of the memory allocated for any of the C-style key. It will not allocate memory for it. It will not delete memory for it. As a result, the following code sniplet will cause memory leak.

while (1)\{ str=(char$\ast$)ckd\_\-calloc(str\_\-length,sizeof(char$\ast$)) if(hash\_\-enter(ht,str,id)!=id)\{ printf(\char`\"{}fail to add key str \%s with val id \%d$\backslash$n\char`\"{},str,id)\} \} A note by dhuggins on 20061010: Changed this to use void $\ast$ instead of int32 as the value type, so that arbitrary objects can be inserted into a hash table (in a way that won't crash on 64-bit machines ;) The hash table structures. Each hash table is identified by a hash\_\-table\_\-t structure. hash\_\-table\_\-t.table is pre-allocated for a user-controlled max size, and is initially empty. As new entries are created (using hash\_\-enter()), the empty entries get filled. If multiple keys hash to the same entry, new entries are allocated and linked together in a linear list. 

\subsection{Function Documentation}
\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-delete@{hash\_\-table\_\-delete}}
\index{hash\_\-table\_\-delete@{hash\_\-table\_\-delete}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-delete}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-delete (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key})}\label{hash__table_8h_f1d87b1b825c302473f2d7c5a3b88475}


Delete an entry with given key and associated value to hash table h. 

Return the value associated with the key (NULL if it did not exist) \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which a key will be deleted \item[{\em 
key}]In: C-style NULL-terminated key string for the new entry \end{description}
\end{Desc}


Definition at line 530 of file hash\_\-table.c.

References hash\_\-table\_\-delete().

Referenced by hash\_\-table\_\-delete().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-delete\_\-bkey@{hash\_\-table\_\-delete\_\-bkey}}
\index{hash\_\-table\_\-delete\_\-bkey@{hash\_\-table\_\-delete\_\-bkey}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-delete\_\-bkey}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-delete\_\-bkey (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  size\_\-t {\em len})}\label{hash__table_8h_a2ab1f5eb2f1b4689645d1e1c19dc887}


Like hash\_\-table\_\-delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 

So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH\_\-CASE\_\-YES option. Otherwise, the results are unpredictable. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which a key will be deleted \item[{\em 
key}]In: C-style NULL-terminated key string for the new entry \end{description}
\end{Desc}


Definition at line 568 of file hash\_\-table.c.

References hash\_\-table\_\-delete\_\-bkey().

Referenced by hash\_\-table\_\-delete\_\-bkey().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-display@{hash\_\-table\_\-display}}
\index{hash\_\-table\_\-display@{hash\_\-table\_\-display}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-display}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void hash\_\-table\_\-display (hash\_\-table\_\-t $\ast$ {\em h}, \/  int32 {\em showkey})}\label{hash__table_8h_2721f6b601c80ceeeae570589fd12e38}


Display a hash-with-chaining representation on the screen. 

Currently, it will only works for situation where hash\_\-enter was used to enter the keys. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Hash table to display \item[{\em 
showkey}]In: Show the string or not, Use 0 if hash\_\-enter\_\-bkey was used. \end{description}
\end{Desc}


Definition at line 580 of file hash\_\-table.c.

References E\_\-INFOCONT, hash\_\-table\_\-display(), hash\_\-entry\_\-s::key, hash\_\-entry\_\-s::len, hash\_\-entry\_\-s::next, and hash\_\-entry\_\-s::val.

Referenced by hash\_\-table\_\-display().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-empty@{hash\_\-table\_\-empty}}
\index{hash\_\-table\_\-empty@{hash\_\-table\_\-empty}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-empty}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void hash\_\-table\_\-empty (hash\_\-table\_\-t $\ast$ {\em h})}\label{hash__table_8h_cab374d21e25009d397642e3465308c7}


Delete all entries from a hash\_\-table. 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table \end{description}
\end{Desc}


Definition at line 490 of file hash\_\-table.c.

References ckd\_\-free(), hash\_\-table\_\-empty(), and hash\_\-entry\_\-s::next.

Referenced by hash\_\-table\_\-empty(), and ngram\_\-model\_\-set\_\-map\_\-words().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-enter@{hash\_\-table\_\-enter}}
\index{hash\_\-table\_\-enter@{hash\_\-table\_\-enter}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-enter}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-enter (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  void $\ast$ {\em val})}\label{hash__table_8h_ebfe63c3869c271b125a8413ee384412}


Try to add a new entry with given key and associated value to hash table h. 

If key doesn't already exist in hash table, the addition is successful, and the return value is val. But if key already exists, return its existing associated value. (The hash table is unchanged; it is up to the caller to resolve the conflict.) \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which to create entry \item[{\em 
key}]In: C-style NULL-terminated key string for the new entry \item[{\em 
val}]In: Value to be associated with above key \end{description}
\end{Desc}


Definition at line 508 of file hash\_\-table.c.

References hash\_\-table\_\-enter().

Referenced by cmd\_\-ln\_\-parse\_\-r(), hash\_\-table\_\-enter(), and huff\_\-code\_\-read().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-enter\_\-bkey@{hash\_\-table\_\-enter\_\-bkey}}
\index{hash\_\-table\_\-enter\_\-bkey@{hash\_\-table\_\-enter\_\-bkey}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-enter\_\-bkey}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-enter\_\-bkey (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  size\_\-t {\em len}, \/  void $\ast$ {\em val})}\label{hash__table_8h_6f5752fadefe2662adb2c141f1511062}


Like hash\_\-table\_\-enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 

So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH\_\-CASE\_\-YES option. Otherwise, the results are unpredictable. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which to create entry \item[{\em 
key}]In: Key buffer \item[{\em 
len}]In: Length of above key buffer \item[{\em 
val}]In: Value to be associated with above key \end{description}
\end{Desc}


Definition at line 542 of file hash\_\-table.c.

References ckd\_\-free(), and hash\_\-table\_\-enter\_\-bkey().

Referenced by hash\_\-table\_\-enter\_\-bkey(), and huff\_\-code\_\-read().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-free@{hash\_\-table\_\-free}}
\index{hash\_\-table\_\-free@{hash\_\-table\_\-free}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void hash\_\-table\_\-free (hash\_\-table\_\-t $\ast$ {\em h})}\label{hash__table_8h_0a588c22946f8cc16328973035ed19e3}


Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries. 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table to free \end{description}
\end{Desc}


Definition at line 692 of file hash\_\-table.c.

References ckd\_\-free(), hash\_\-table\_\-free(), and hash\_\-entry\_\-s::next.

Referenced by cmd\_\-ln\_\-free\_\-r(), cmd\_\-ln\_\-parse\_\-r(), hash\_\-table\_\-free(), huff\_\-code\_\-free(), jsgf\_\-grammar\_\-free(), ngram\_\-model\_\-casefold(), ngram\_\-model\_\-free(), ngram\_\-model\_\-read\_\-classdef(), and ngram\_\-model\_\-set\_\-read().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-iter\_\-next@{hash\_\-table\_\-iter\_\-next}}
\index{hash\_\-table\_\-iter\_\-next@{hash\_\-table\_\-iter\_\-next}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-iter\_\-next}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT hash\_\-iter\_\-t$\ast$ hash\_\-table\_\-iter\_\-next (hash\_\-iter\_\-t $\ast$ {\em itor})}\label{hash__table_8h_d023321efab26a30bd6d855fbdbe08a3}


Get the next key-value pair in iteration. 

This function automatically frees the iterator object upon reaching the final entry.

\begin{Desc}
\item[Returns:]the next entry in the hash table, or NULL if done. \end{Desc}


Definition at line 660 of file hash\_\-table.c.

References hash\_\-table\_\-iter\_\-free(), and hash\_\-table\_\-iter\_\-next().

Referenced by hash\_\-table\_\-iter(), hash\_\-table\_\-iter\_\-next(), and jsgf\_\-grammar\_\-free().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-lookup@{hash\_\-table\_\-lookup}}
\index{hash\_\-table\_\-lookup@{hash\_\-table\_\-lookup}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-lookup}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 hash\_\-table\_\-lookup (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  void $\ast$$\ast$ {\em val})}\label{hash__table_8h_9a1e5ed410eb96f514b00fdce770fbd7}


Look up a key in a hash table and optionally return the associated value. 

\begin{Desc}
\item[Returns:]0 if key found in hash table, else -1. \end{Desc}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table being searched \item[{\em 
key}]In: C-style NULL-terminated string whose value is sought \item[{\em 
val}]Out: $\ast$val = value associated with key. If this is NULL, no value will be returned. \end{description}
\end{Desc}


Definition at line 309 of file hash\_\-table.c.

References hash\_\-table\_\-lookup(), and hash\_\-entry\_\-s::val.

Referenced by cmd\_\-ln\_\-access\_\-r(), cmd\_\-ln\_\-exists\_\-r(), cmd\_\-ln\_\-parse\_\-r(), hash\_\-table\_\-lookup(), hash\_\-table\_\-lookup\_\-int32(), huff\_\-code\_\-encode\_\-str(), jsgf\_\-get\_\-rule(), and ngram\_\-model\_\-set\_\-read().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-lookup\_\-bkey@{hash\_\-table\_\-lookup\_\-bkey}}
\index{hash\_\-table\_\-lookup\_\-bkey@{hash\_\-table\_\-lookup\_\-bkey}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-lookup\_\-bkey}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 hash\_\-table\_\-lookup\_\-bkey (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  size\_\-t {\em len}, \/  void $\ast$$\ast$ {\em val})}\label{hash__table_8h_91f5b3924c0e3a50f94c86bb5fd078e8}


Like hash\_\-lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 

So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH\_\-CASE\_\-YES option. Otherwise, the results are unpredictable. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table being searched \item[{\em 
key}]In: Key buffer \item[{\em 
len}]In: Length of above key buffer \item[{\em 
val}]Out: $\ast$val = value associated with key. If this is NULL, no value will be returned. \end{description}
\end{Desc}


Definition at line 344 of file hash\_\-table.c.

References ckd\_\-free(), hash\_\-table\_\-lookup\_\-bkey(), and hash\_\-entry\_\-s::val.

Referenced by hash\_\-table\_\-lookup\_\-bkey(), hash\_\-table\_\-lookup\_\-bkey\_\-int32(), and huff\_\-code\_\-encode\_\-int().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-lookup\_\-bkey\_\-int32@{hash\_\-table\_\-lookup\_\-bkey\_\-int32}}
\index{hash\_\-table\_\-lookup\_\-bkey\_\-int32@{hash\_\-table\_\-lookup\_\-bkey\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-lookup\_\-bkey\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 hash\_\-table\_\-lookup\_\-bkey\_\-int32 (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  size\_\-t {\em len}, \/  int32 $\ast$ {\em val})}\label{hash__table_8h_cc530eda0b105745cf3a47cc3c1148e4}


Look up a 32-bit integer value in a hash table. 

This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table being searched \item[{\em 
key}]In: Key buffer \item[{\em 
len}]In: Length of above key buffer \item[{\em 
val}]Out: $\ast$val = value associated with key. If this is NULL, no value will be returned. \end{description}
\end{Desc}


Definition at line 365 of file hash\_\-table.c.

References hash\_\-table\_\-lookup\_\-bkey(), and hash\_\-table\_\-lookup\_\-bkey\_\-int32().

Referenced by hash\_\-table\_\-lookup\_\-bkey\_\-int32().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-lookup\_\-int32@{hash\_\-table\_\-lookup\_\-int32}}
\index{hash\_\-table\_\-lookup\_\-int32@{hash\_\-table\_\-lookup\_\-int32}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-lookup\_\-int32}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 hash\_\-table\_\-lookup\_\-int32 (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  int32 $\ast$ {\em val})}\label{hash__table_8h_caf27e8e7e336faf6653649937c42ed8}


Look up a 32-bit integer value in a hash table. 

This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table being searched \item[{\em 
key}]In: C-style NULL-terminated string whose value is sought \item[{\em 
val}]Out: $\ast$val = value associated with key. If this is NULL, no value will be returned. \end{description}
\end{Desc}


Definition at line 329 of file hash\_\-table.c.

References hash\_\-table\_\-lookup(), and hash\_\-table\_\-lookup\_\-int32().

Referenced by hash\_\-table\_\-lookup\_\-int32(), ngram\_\-unknown\_\-wid(), and ngram\_\-wid().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-new@{hash\_\-table\_\-new}}
\index{hash\_\-table\_\-new@{hash\_\-table\_\-new}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-new}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT hash\_\-table\_\-t$\ast$ hash\_\-table\_\-new (int32 {\em size}, \/  int32 {\em casearg})}\label{hash__table_8h_56d93e8c03e066b77377ac6eab50cfae}


Allocate a new hash table for a given expected size. 

\begin{Desc}
\item[Note:]Case sensitivity of hash keys applies to 7-bit ASCII characters only, and is not locale-dependent.\end{Desc}
\begin{Desc}
\item[Returns:]handle to allocated hash table. \end{Desc}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
size}]In: Expected number of entries in the table \item[{\em 
casearg}]In: Whether case insensitive for key comparisons. When 1, case is insentitive, 0, case is sensitive. \end{description}
\end{Desc}


Definition at line 158 of file hash\_\-table.c.

References ckd\_\-calloc, and hash\_\-table\_\-new().

Referenced by cmd\_\-ln\_\-parse\_\-r(), hash\_\-table\_\-new(), huff\_\-code\_\-read(), jsgf\_\-grammar\_\-new(), ngram\_\-model\_\-casefold(), ngram\_\-model\_\-read\_\-classdef(), and ngram\_\-model\_\-set\_\-read().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-replace@{hash\_\-table\_\-replace}}
\index{hash\_\-table\_\-replace@{hash\_\-table\_\-replace}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-replace}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-replace (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  void $\ast$ {\em val})}\label{hash__table_8h_e61b28ea189a98ef8f2a3c5521482968}


Add a new entry with given key and value to hash table h. 

If the key already exists, its value is replaced with the given value, and the previous value is returned, otherwise val is returned.

A very important but subtle point: The key pointer in the hash table is {\bf replaced} with the pointer passed to this function. In general you should always pass a pointer to \doxyref{hash\_\-table\_\-enter()}{p.}{hash__table_8h_ebfe63c3869c271b125a8413ee384412} whose lifetime matches or exceeds that of the hash table. In some rare cases it is convenient to initially enter a value with a short-lived key, then later replace that with a long-lived one. This behaviour allows this to happen. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which to create entry \item[{\em 
key}]In: C-style NULL-terminated key string for the new entry \item[{\em 
val}]In: Value to be associated with above key \end{description}
\end{Desc}


Definition at line 519 of file hash\_\-table.c.

References hash\_\-table\_\-replace().

Referenced by cmd\_\-ln\_\-parse\_\-r(), and hash\_\-table\_\-replace().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-replace\_\-bkey@{hash\_\-table\_\-replace\_\-bkey}}
\index{hash\_\-table\_\-replace\_\-bkey@{hash\_\-table\_\-replace\_\-bkey}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-replace\_\-bkey}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void$\ast$ hash\_\-table\_\-replace\_\-bkey (hash\_\-table\_\-t $\ast$ {\em h}, \/  const char $\ast$ {\em key}, \/  size\_\-t {\em len}, \/  void $\ast$ {\em val})}\label{hash__table_8h_273237d63833e5625c830f421d9463de}


Like hash\_\-table\_\-replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. 

So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH\_\-CASE\_\-YES option. Otherwise, the results are unpredictable. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Handle of hash table in which to create entry \item[{\em 
key}]In: Key buffer \item[{\em 
len}]In: Length of above key buffer \item[{\em 
val}]In: Value to be associated with above key \end{description}
\end{Desc}


Definition at line 555 of file hash\_\-table.c.

References ckd\_\-free(), and hash\_\-table\_\-replace\_\-bkey().

Referenced by hash\_\-table\_\-replace\_\-bkey().\index{hash\_\-table.h@{hash\_\-table.h}!hash\_\-table\_\-tolist@{hash\_\-table\_\-tolist}}
\index{hash\_\-table\_\-tolist@{hash\_\-table\_\-tolist}!hash_table.h@{hash\_\-table.h}}
\subsubsection[{hash\_\-table\_\-tolist}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT {\bf glist\_\-t} hash\_\-table\_\-tolist (hash\_\-table\_\-t $\ast$ {\em h}, \/  int32 $\ast$ {\em count})}\label{hash__table_8h_61f59389f05d8871003da4692a9c2acc}


Build a glist of valid hash\_\-entry\_\-t pointers from the given hash table. 

Return the list. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
h}]In: Hash table from which list is to be generated \item[{\em 
count}]Out: Number of entries in the list. If this is NULL, no count will be returned. \end{description}
\end{Desc}


Definition at line 620 of file hash\_\-table.c.

References glist\_\-add\_\-ptr(), hash\_\-table\_\-tolist(), and hash\_\-entry\_\-s::key.

Referenced by cmd\_\-ln\_\-free\_\-r(), hash\_\-table\_\-tolist(), ngram\_\-model\_\-read\_\-classdef(), and ngram\_\-model\_\-set\_\-read().