\section{include/pio.h File Reference}
\label{pio_8h}\index{include/pio.h@{include/pio.h}}
file IO related operations.  


{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$sys/stat.h$>$}\par
{\tt \#include $<$sphinxbase\_\-export.h$>$}\par
{\tt \#include $<$prim\_\-type.h$>$}\par
\subsection*{Data Structures}
\begin{CompactItemize}
\item 
struct {\bf lineiter\_\-t}
\begin{CompactList}\small\item\em Line iterator for files. \item\end{CompactList}\end{CompactItemize}
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define \textbf{myfopen}(file, mode)~\_\-myfopen((file),(mode),\_\-\_\-FILE\_\-\_\-,\_\-\_\-LINE\_\-\_\-)\label{pio_8h_96b37e449c7f8698fcfafac1c46cebb2}

\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef struct bit\_\-encode\_\-s {\bf bit\_\-encode\_\-t}\label{pio_8h_e72c3bec19638da72dad3849f75c0cd9}

\begin{CompactList}\small\item\em Bitstream encoder - for writing compressed files. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
SPHINXBASE\_\-EXPORT FILE $\ast$ {\bf fopen\_\-comp} (const char $\ast$file, const char $\ast$mode, int32 $\ast$ispipe)
\begin{CompactList}\small\item\em Like fopen, but use popen and zcat if it is determined that \char`\"{}file\char`\"{} is compressed (i.e., has a .z, .Z, .gz, or .GZ extension). \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf fclose\_\-comp} (FILE $\ast$fp, int32 ispipe)
\begin{CompactList}\small\item\em Close a file opened using fopen\_\-comp. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT FILE $\ast$ {\bf fopen\_\-compchk} (const char $\ast$file, int32 $\ast$ispipe)
\begin{CompactList}\small\item\em Open a file for reading, but if file not present try to open compressed version (if file is uncompressed, and vice versa). \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT FILE $\ast$ {\bf \_\-myfopen} (const char $\ast$file, const char $\ast$mode, const char $\ast$pgm, int32 line)\label{pio_8h_a22301f25d56be607c9ff45f2c935b14}

\begin{CompactList}\small\item\em Wrapper around fopen to check for failure and E\_\-FATAL if failed. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf fread\_\-retry} (void $\ast$pointer, int32 size, int32 num\_\-items, FILE $\ast$stream)
\begin{CompactList}\small\item\em NFS file reads seem to fail now and then. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT char $\ast$ {\bf fread\_\-line} (FILE $\ast$stream, size\_\-t $\ast$out\_\-len)
\begin{CompactList}\small\item\em Read a line of arbitrary length from a file and return it as a newly allocated string. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT {\bf lineiter\_\-t} $\ast$ {\bf lineiter\_\-start} (FILE $\ast$fh)\label{pio_8h_22d0125ab198f02f8bbe543417d99566}

\begin{CompactList}\small\item\em Start reading lines from a file. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT {\bf lineiter\_\-t} $\ast$ {\bf lineiter\_\-next} ({\bf lineiter\_\-t} $\ast$li)\label{pio_8h_ff8df0b6928746d61b3520555263f71e}

\begin{CompactList}\small\item\em Move to the next line in the file. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT void {\bf lineiter\_\-free} ({\bf lineiter\_\-t} $\ast$li)\label{pio_8h_3f80e5d4d666426cef229dd41237d9cf}

\begin{CompactList}\small\item\em Stop reading lines from a file. \item\end{CompactList}\item 
{\bf bit\_\-encode\_\-t} $\ast$ {\bf bit\_\-encode\_\-attach} (FILE $\ast$outfh)\label{pio_8h_82e4694a4c13c96550f2410f8c63b1f5}

\begin{CompactList}\small\item\em Attach bitstream encoder to a file. \item\end{CompactList}\item 
{\bf bit\_\-encode\_\-t} $\ast$ {\bf bit\_\-encode\_\-retain} ({\bf bit\_\-encode\_\-t} $\ast$be)\label{pio_8h_da6d9bb75e08493cde00d396dae088f1}

\begin{CompactList}\small\item\em Retain pointer to a bit encoder. \item\end{CompactList}\item 
int {\bf bit\_\-encode\_\-free} ({\bf bit\_\-encode\_\-t} $\ast$be)
\begin{CompactList}\small\item\em Release pointer to a bit encoder. \item\end{CompactList}\item 
int {\bf bit\_\-encode\_\-write} ({\bf bit\_\-encode\_\-t} $\ast$be, unsigned char const $\ast$bits, int nbits)\label{pio_8h_59d83bd5850d9ec58175c566d6d48f71}

\begin{CompactList}\small\item\em Write bits to encoder. \item\end{CompactList}\item 
int {\bf bit\_\-encode\_\-write\_\-cw} ({\bf bit\_\-encode\_\-t} $\ast$be, uint32 codeword, int nbits)\label{pio_8h_e71dedb663c8e3ae8b91dbfbc95ac420}

\begin{CompactList}\small\item\em Write lowest-order bits of codeword to encoder. \item\end{CompactList}\item 
int {\bf bit\_\-encode\_\-flush} ({\bf bit\_\-encode\_\-t} $\ast$be)\label{pio_8h_3e818645e567961225977a1923debc3d}

\begin{CompactList}\small\item\em Flush any unwritten bits, zero-padding if necessary. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf stat\_\-retry} (const char $\ast$file, struct stat $\ast$statbuf)
\begin{CompactList}\small\item\em There is no bitstream decoder, because a stream abstraction is too slow. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int32 {\bf stat\_\-mtime} (const char $\ast$file)\label{pio_8h_289e3a1582ab60563ae0689979992669}

\begin{CompactList}\small\item\em Return time of last modification for the given file, or -1 if stat fails. \item\end{CompactList}\item 
SPHINXBASE\_\-EXPORT int {\bf build\_\-directory} (const char $\ast$path)
\begin{CompactList}\small\item\em Create a directory and all of its parent directories, as needed. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
file IO related operations. 

Custom fopen with error checking is implemented. fopen\_\-comp can open a file with .z, .Z, .gz or .GZ extension

WARNING: Usage of stat\_\-retry will results in 100s of waiting time if the file doesn't exist. 

Definition in file {\bf pio.h}.

\subsection{Function Documentation}
\index{pio.h@{pio.h}!bit\_\-encode\_\-free@{bit\_\-encode\_\-free}}
\index{bit\_\-encode\_\-free@{bit\_\-encode\_\-free}!pio.h@{pio.h}}
\subsubsection[{bit\_\-encode\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}int bit\_\-encode\_\-free ({\bf bit\_\-encode\_\-t} $\ast$ {\em be})}\label{pio_8h_8330637520174419771670ed740c9049}


Release pointer to a bit encoder. 

Note that this does NOT flush any leftover bits. 

Definition at line 502 of file pio.c.

References bit\_\-encode\_\-free(), and ckd\_\-free().

Referenced by bit\_\-encode\_\-free(), and huff\_\-code\_\-detach().\index{pio.h@{pio.h}!build\_\-directory@{build\_\-directory}}
\index{build\_\-directory@{build\_\-directory}!pio.h@{pio.h}}
\subsubsection[{build\_\-directory}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int build\_\-directory (const char $\ast$ {\em path})}\label{pio_8h_6df697b8a08cd4d11fe7b864dcb99012}


Create a directory and all of its parent directories, as needed. 

\begin{Desc}
\item[Returns:]0 on success, $<$0 on failure. \end{Desc}


Definition at line 599 of file pio.c.

References build\_\-directory(), and E\_\-ERROR.

Referenced by build\_\-directory().\index{pio.h@{pio.h}!fclose\_\-comp@{fclose\_\-comp}}
\index{fclose\_\-comp@{fclose\_\-comp}!pio.h@{pio.h}}
\subsubsection[{fclose\_\-comp}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT void fclose\_\-comp (FILE $\ast$ {\em fp}, \/  int32 {\em ispipe})}\label{pio_8h_87592c3a2d0a00eed9eda014950beb65}


Close a file opened using fopen\_\-comp. 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
fp}]In: File pointer to be closed \item[{\em 
ispipe}]In: ispipe argument that was returned by the corresponding \doxyref{fopen\_\-comp()}{p.}{pio_8h_a3d71506049eb49cf03eff1b89ef281f} call \end{description}
\end{Desc}


Definition at line 175 of file pio.c.

References fclose\_\-comp().

Referenced by fclose\_\-comp().\index{pio.h@{pio.h}!fopen\_\-comp@{fopen\_\-comp}}
\index{fopen\_\-comp@{fopen\_\-comp}!pio.h@{pio.h}}
\subsubsection[{fopen\_\-comp}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT FILE$\ast$ fopen\_\-comp (const char $\ast$ {\em file}, \/  const char $\ast$ {\em mode}, \/  int32 $\ast$ {\em ispipe})}\label{pio_8h_a3d71506049eb49cf03eff1b89ef281f}


Like fopen, but use popen and zcat if it is determined that \char`\"{}file\char`\"{} is compressed (i.e., has a .z, .Z, .gz, or .GZ extension). 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
file}]In: File to be opened \item[{\em 
mode}]In: \char`\"{}r\char`\"{} or \char`\"{}w\char`\"{}, as with normal fopen \item[{\em 
ispipe}]Out: On return $\ast$ispipe is TRUE iff file was opened via a pipe \end{description}
\end{Desc}


Definition at line 98 of file pio.c.

References ckd\_\-free(), E\_\-ERROR, E\_\-ERROR\_\-SYSTEM, E\_\-FATAL, fopen\_\-comp(), and string\_\-join().

Referenced by fopen\_\-comp(), and fopen\_\-compchk().\index{pio.h@{pio.h}!fopen\_\-compchk@{fopen\_\-compchk}}
\index{fopen\_\-compchk@{fopen\_\-compchk}!pio.h@{pio.h}}
\subsubsection[{fopen\_\-compchk}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT FILE$\ast$ fopen\_\-compchk (const char $\ast$ {\em file}, \/  int32 $\ast$ {\em ispipe})}\label{pio_8h_ddfd26392f118f811584721b8d4854ce}


Open a file for reading, but if file not present try to open compressed version (if file is uncompressed, and vice versa). 

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
file}]In: File to be opened \item[{\em 
ispipe}]Out: On return $\ast$ispipe is TRUE iff file was opened via a pipe \end{description}
\end{Desc}


Definition at line 192 of file pio.c.

References ckd\_\-calloc, ckd\_\-free(), E\_\-WARN, fopen\_\-comp(), and fopen\_\-compchk().

Referenced by fopen\_\-compchk().\index{pio.h@{pio.h}!fread\_\-line@{fread\_\-line}}
\index{fread\_\-line@{fread\_\-line}!pio.h@{pio.h}}
\subsubsection[{fread\_\-line}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT char$\ast$ fread\_\-line (FILE $\ast$ {\em stream}, \/  size\_\-t $\ast$ {\em out\_\-len})}\label{pio_8h_11e0daa4f315d01c2e030d3a0abe702c}


Read a line of arbitrary length from a file and return it as a newly allocated string. 

\begin{Desc}
\item[{\bf Deprecated}]Use line iterators instead.\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stream}]The file handle to read from. \item[{\em out\_\-len}]Output: if not NULL, length of the string read. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]allocated string containing the line, or NULL on error or EOF. \end{Desc}


Definition at line 312 of file pio.c.

References ckd\_\-malloc, ckd\_\-realloc, and fread\_\-line().

Referenced by fread\_\-line(), and huff\_\-code\_\-read().\index{pio.h@{pio.h}!fread\_\-retry@{fread\_\-retry}}
\index{fread\_\-retry@{fread\_\-retry}!pio.h@{pio.h}}
\subsubsection[{fread\_\-retry}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 fread\_\-retry (void $\ast$ {\em pointer}, \/  int32 {\em size}, \/  int32 {\em num\_\-items}, \/  FILE $\ast$ {\em stream})}\label{pio_8h_601277430d3221bf1906bb879ae26d3e}


NFS file reads seem to fail now and then. 

Use the following functions in place of the regular fread. It retries failed freads several times and quits only if all of them fail. Be aware, however, that even normal failures such as attempting to read beyond EOF will trigger such retries, wasting about a minute in retries. Arguments identical to regular fread. 

Definition at line 344 of file pio.c.

References E\_\-ERROR\_\-SYSTEM, and fread\_\-retry().

Referenced by feat\_\-s2mfc\_\-read(), and fread\_\-retry().\index{pio.h@{pio.h}!stat\_\-retry@{stat\_\-retry}}
\index{stat\_\-retry@{stat\_\-retry}!pio.h@{pio.h}}
\subsubsection[{stat\_\-retry}]{\setlength{\rightskip}{0pt plus 5cm}SPHINXBASE\_\-EXPORT int32 stat\_\-retry (const char $\ast$ {\em file}, \/  struct stat $\ast$ {\em statbuf})}\label{pio_8h_0ba35509687e80ee65ba731c7cfcad9b}


There is no bitstream decoder, because a stream abstraction is too slow. 

Instead we read blocks of bits and treat them as bitvectors. Like fread\_\-retry, but for stat. Arguments identical to regular stat. Return value: 0 if successful, -1 if stat failed several attempts. 

Definition at line 426 of file pio.c.

References E\_\-ERROR\_\-SYSTEM, and stat\_\-retry().

Referenced by feat\_\-s2mfc\_\-read(), stat\_\-mtime(), and stat\_\-retry().